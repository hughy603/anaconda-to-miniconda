name: Release

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      require_approval:
        description: 'Require manual approval before release'
        required: true
        default: true
        type: boolean

# Prevent concurrent runs
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

# Security: Minimal required permissions
permissions:
  contents: write
  issues: write
  pull-requests: write
  packages: write
  security-events: write

env:
  PYTHON_VERSION: ${{ vars.PYTHON_VERSION || '3.11' }}
  UV_VERSION: ${{ vars.UV_VERSION || '0.6.14' }}
  ACT_LOCAL_TESTING: ${{ vars.ACT_LOCAL_TESTING || 'false' }}
  # Security: Use environment variables for sensitive values
  PYPI_TOKEN: ${{ secrets.PYPI_API_TOKEN }}
  GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

jobs:
  validate:
    name: Validate Release
    runs-on: ubuntu-latest
    timeout-minutes: ${{ vars.TEST_TIMEOUT_MINUTES && fromJSON(vars.TEST_TIMEOUT_MINUTES) || 30 }}
    environment: production
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Required for semantic-release

      - name: Setup Python
        uses: ./.github/actions/setup-python
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          uv-version: ${{ env.UV_VERSION }}
          cache-key: release-validate
          extra-cache-paths: |
            dist/
            *.egg-info/
            ~/.cache/uv
            ~/.cache/pip

      - name: Create virtual environment
        run: |
          echo "::group::Creating Virtual Environment"
          uv venv .venv
          source .venv/bin/activate
          echo "::endgroup::"

      - name: Install dependencies
        run: |
          echo "::group::Installing Dependencies"
          # Install from lock file with all extras
          uv pip install -r requirements.lock
          # Install build tools separately
          uv pip install build hatch python-semantic-release --system
          echo "::endgroup::"

      - name: Run pre-commit checks
        run: |
          echo "::group::Running Pre-commit Checks"
          # Run pre-commit with existing hooks
          uv run pre-commit run --all-files
          echo "::endgroup::"

      - name: Build package
        run: |
          echo "::group::Building Package"
          # Install production dependencies
          uv pip install -e . -r requirements-prod.lock
          # Build with proper isolation
          python -m build
          # Verify package contents
          echo "::notice::Package contents:"
          tar -tvf dist/*.tar.gz
          echo "::endgroup::"

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts
          path: |
            dist/
            *.egg-info/
          retention-days: 30

      - name: Validate release readiness
        id: validate
        continue-on-error: true
        run: |
          echo "::group::Validating Release"
          # Check if build artifacts exist
          if [ ! -d "dist" ]; then
            echo "::error::Build artifacts not found in dist/"
            exit 1
          fi

          # Check if version file exists
          if [ ! -f "src/conda_forge_converter/_version.py" ]; then
            echo "::error::Version file not found"
            exit 1
          fi

          # Check if changelog exists
          if [ ! -f "CHANGELOG.md" ]; then
            echo "::error::CHANGELOG.md not found"
            exit 1
          fi

          # Get current version
          CURRENT_VERSION=$(python -c "from conda_forge_converter import __version__; print(__version__)")
          echo "current_version=$CURRENT_VERSION" >> "$GITHUB_OUTPUT"
          echo "::notice::Release validation passed"
          echo "::endgroup::"

  test:
    name: Test (${{ matrix.os }}, Python ${{ matrix.python-version }})
    needs: [validate]
    runs-on: ${{ matrix.os }}
    timeout-minutes: ${{ vars.TEST_TIMEOUT_MINUTES && fromJSON(vars.TEST_TIMEOUT_MINUTES) || 30 }}
    strategy:
      matrix:
        python-version: ["3.11", "3.12"]
        os: [ubuntu-latest, windows-latest, macos-latest]
      fail-fast: false

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Python
        uses: ./.github/actions/setup-python
        with:
          python-version: ${{ matrix.python-version }}
          uv-version: ${{ env.UV_VERSION }}
          cache-key: release-test-${{ matrix.os }}-py${{ matrix.python-version }}
          extra-cache-paths: |
            ~/.cache/hatch
            .coverage
            coverage.xml
            ~/.cache/uv
            ~/.cache/pip

      - name: Create virtual environment
        run: |
          echo "::group::Creating Virtual Environment"
          uv venv .venv
          source .venv/bin/activate
          echo "::endgroup::"

      - name: Install dependencies
        run: |
          echo "::group::Installing Dependencies"
          # Install from lock file with all extras
          uv pip install -r requirements.lock
          # Install test dependencies separately
          uv pip install hatch python-semantic-release pre-commit --system
          # Install dev dependencies for linting
          uv pip install -e ".[all]"
          echo "::endgroup::"

      - name: Run linting and type checking
        if: matrix.os == 'ubuntu-latest' && matrix.python-version == '3.11'
        run: |
          hatch run lint
          hatch run type-check

      - name: Run tests
        id: run-tests
        run: |
          echo "::group::Running Tests"
          # Run tests with coverage in isolated environment
          hatch run test -- --cov=src --cov-report=xml --junitxml=test-results.xml
          echo "::endgroup::"

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results-${{ matrix.os }}-py${{ matrix.python-version }}
          path: |
            .coverage
            coverage.xml
            test-results.xml
            .pytest_cache/
          retention-days: 30

      # - name: Upload coverage to Codecov
      #   uses: codecov/codecov-action@v4
      #   with:
      #     token: ${{ secrets.CODECOV_TOKEN }}
      #     files: coverage.xml
      #     fail_ci_if_error: true

  release:
    name: Create Release
    needs: [test]
    if: ${{ github.event.inputs.require_approval == 'true' || always() }}
    runs-on: ubuntu-latest
    timeout-minutes: ${{ vars.RELEASE_TIMEOUT_MINUTES && fromJSON(vars.RELEASE_TIMEOUT_MINUTES) || 90 }}
    environment: production
    permissions:
      contents: write
      id-token: write
      packages: write
    outputs:
      version: ${{ steps.release.outputs.version }}

    steps:
      - name: Setup Python
        uses: ./.github/actions/setup-python
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          uv-version: ${{ env.UV_VERSION }}
          cache-key: release
          extra-cache-paths: |
            dist/
            *.egg-info/
            ~/.cache/uv
            ~/.cache/pip

      - name: Create virtual environment
        run: |
          echo "::group::Creating Virtual Environment"
          uv venv .venv
          source .venv/bin/activate
          echo "::endgroup::"

      - name: Install dependencies
        run: |
          echo "::group::Installing Dependencies"
          uv pip install -r requirements-prod.lock
          uv pip install python-semantic-release build twine hatch --system
          echo "::endgroup::"

      - name: Build package
        run: |
          echo "::group::Building Package"
          # Build with proper isolation
          python -m build
          # Verify package contents
          echo "::notice::Package contents:"
          tar -tvf dist/*.tar.gz
          echo "::endgroup::"

      - name: Semantic Release
        id: release
        if: ${{ !env.ACT_LOCAL_TESTING || env.ACT_LOCAL_TESTING != 'true' }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          semantic-release version --no-commit --no-tag --no-push --no-vcs-release
          VERSION=$(python -c "from conda_forge_converter import __version__; print(__version__)")
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"

      - name: Generate changelog
        run: |
          semantic-release changelog --unreleased
          cat CHANGELOG.md

      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          name: v${{ steps.release.outputs.version }}
          body_path: CHANGELOG.md
          draft: false
          prerelease: false
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and publish
        id: publish
        if: ${{ !env.ACT_LOCAL_TESTING || env.ACT_LOCAL_TESTING != 'true' }}
        run: |
          echo "::group::Publishing Release"
          # Verify version matches tag
          TAG_VERSION=${GITHUB_REF#refs/tags/v}
          PYTHON_VERSION=$(python -c "from conda_forge_converter import __version__; print(__version__)")
          if [ "$TAG_VERSION" != "$PYTHON_VERSION" ]; then
            echo "::error::Version mismatch: Tag $TAG_VERSION != Python $PYTHON_VERSION"
            exit 1
          fi
          semantic-release publish
          VERSION=$(python -c "from conda_forge_converter import __version__; print(__version__)")
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "::endgroup::"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPOSITORY_URL: https://upload.pypi.org/legacy/
          PYPI_TOKEN: ${{ secrets.PYPI_API_TOKEN }}

      - name: Upload build artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts
          path: |
            dist/
            *.egg-info/
          retention-days: 90

      - name: Install released package
        id: install
        if: ${{ !env.ACT_LOCAL_TESTING || env.ACT_LOCAL_TESTING != 'true' }}
        run: |
          echo "::group::Installing Released Package"
          uv pip install conda-forge-converter==${{ steps.release.outputs.version }} --no-cache-dir
          # Verify installation
          if conda-forge-converter --version | grep -q "${{ steps.release.outputs.version }}"; then
            echo "status=success" >> "$GITHUB_OUTPUT"
          else
            echo "status=failure" >> "$GITHUB_OUTPUT"
            exit 1
          fi
          echo "::endgroup::"

  health-check:
    name: Deployment Health Check
    needs: [release]
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: Setup Python
        uses: ./.github/actions/setup-python
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          uv-version: ${{ env.UV_VERSION }}
          cache-key: health-check
          extra-cache-paths: |
            ~/.cache/uv
            ~/.cache/pip

      - name: Create virtual environment
        run: |
          echo "::group::Creating Virtual Environment"
          uv venv .venv
          source .venv/bin/activate
          echo "::endgroup::"

      - name: Install released package
        id: install
        if: ${{ !env.ACT_LOCAL_TESTING || env.ACT_LOCAL_TESTING != 'true' }}
        run: |
          echo "::group::Installing Released Package"
          uv pip install conda-forge-converter==${{ needs.release.outputs.version }} --no-cache-dir
          # Verify installation
          if conda-forge-converter --version | grep -q "${{ needs.release.outputs.version }}"; then
            echo "status=success" >> "$GITHUB_OUTPUT"
          else
            echo "status=failure" >> "$GITHUB_OUTPUT"
            exit 1
          fi
          echo "::endgroup::"

      - name: Run smoke tests
        if: steps.install.outputs.status == 'success'
        run: |
          echo "::group::Running Smoke Tests"
          # Verify version matches
          INSTALLED_VERSION=$(conda-forge-converter --version)
          EXPECTED_VERSION=${{ needs.release.outputs.version }}
          if [ "$INSTALLED_VERSION" != "$EXPECTED_VERSION" ]; then
            echo "::error::Version mismatch: Installed $INSTALLED_VERSION != Expected $EXPECTED_VERSION"
            exit 1
          fi
          # Run basic commands
          conda-forge-converter --help
          conda-forge-converter --version
          # Add more comprehensive smoke tests as needed
          echo "::endgroup::"
